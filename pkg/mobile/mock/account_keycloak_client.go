// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/cloudtrust/keycloak-bridge/pkg/mobile (interfaces: KeycloakClient,AuthorizationManager,IdentificationAuthorizationManager)
//
// Generated by this command:
//
//	mockgen --build_flags=--mod=mod -destination=./mock/account_keycloak_client.go -package=mock -mock_names=KeycloakClient=KeycloakClient,AuthorizationManager=AuthorizationManager,IdentificationAuthorizationManager=IdentificationAuthorizationManager github.com/cloudtrust/keycloak-bridge/pkg/mobile KeycloakClient,AuthorizationManager,IdentificationAuthorizationManager
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	keycloak "github.com/cloudtrust/keycloak-client/v2"
	gomock "go.uber.org/mock/gomock"
)

// KeycloakClient is a mock of KeycloakClient interface.
type KeycloakClient struct {
	ctrl     *gomock.Controller
	recorder *KeycloakClientMockRecorder
	isgomock struct{}
}

// KeycloakClientMockRecorder is the mock recorder for KeycloakClient.
type KeycloakClientMockRecorder struct {
	mock *KeycloakClient
}

// NewKeycloakClient creates a new mock instance.
func NewKeycloakClient(ctrl *gomock.Controller) *KeycloakClient {
	mock := &KeycloakClient{ctrl: ctrl}
	mock.recorder = &KeycloakClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *KeycloakClient) EXPECT() *KeycloakClientMockRecorder {
	return m.recorder
}

// GetRealm mocks base method.
func (m *KeycloakClient) GetRealm(accessToken, realmName string) (keycloak.RealmRepresentation, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRealm", accessToken, realmName)
	ret0, _ := ret[0].(keycloak.RealmRepresentation)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRealm indicates an expected call of GetRealm.
func (mr *KeycloakClientMockRecorder) GetRealm(accessToken, realmName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRealm", reflect.TypeOf((*KeycloakClient)(nil).GetRealm), accessToken, realmName)
}

// GetUser mocks base method.
func (m *KeycloakClient) GetUser(accessToken, realmName, userID string) (keycloak.UserRepresentation, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUser", accessToken, realmName, userID)
	ret0, _ := ret[0].(keycloak.UserRepresentation)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUser indicates an expected call of GetUser.
func (mr *KeycloakClientMockRecorder) GetUser(accessToken, realmName, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*KeycloakClient)(nil).GetUser), accessToken, realmName, userID)
}

// AuthorizationManager is a mock of AuthorizationManager interface.
type AuthorizationManager struct {
	ctrl     *gomock.Controller
	recorder *AuthorizationManagerMockRecorder
	isgomock struct{}
}

// AuthorizationManagerMockRecorder is the mock recorder for AuthorizationManager.
type AuthorizationManagerMockRecorder struct {
	mock *AuthorizationManager
}

// NewAuthorizationManager creates a new mock instance.
func NewAuthorizationManager(ctrl *gomock.Controller) *AuthorizationManager {
	mock := &AuthorizationManager{ctrl: ctrl}
	mock.recorder = &AuthorizationManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *AuthorizationManager) EXPECT() *AuthorizationManagerMockRecorder {
	return m.recorder
}

// CheckAuthorizationOnTargetUser mocks base method.
func (m *AuthorizationManager) CheckAuthorizationOnTargetUser(ctx context.Context, action, targetRealm, userID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckAuthorizationOnTargetUser", ctx, action, targetRealm, userID)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckAuthorizationOnTargetUser indicates an expected call of CheckAuthorizationOnTargetUser.
func (mr *AuthorizationManagerMockRecorder) CheckAuthorizationOnTargetUser(ctx, action, targetRealm, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckAuthorizationOnTargetUser", reflect.TypeOf((*AuthorizationManager)(nil).CheckAuthorizationOnTargetUser), ctx, action, targetRealm, userID)
}

// IdentificationAuthorizationManager is a mock of IdentificationAuthorizationManager interface.
type IdentificationAuthorizationManager struct {
	ctrl     *gomock.Controller
	recorder *IdentificationAuthorizationManagerMockRecorder
	isgomock struct{}
}

// IdentificationAuthorizationManagerMockRecorder is the mock recorder for IdentificationAuthorizationManager.
type IdentificationAuthorizationManagerMockRecorder struct {
	mock *IdentificationAuthorizationManager
}

// NewIdentificationAuthorizationManager creates a new mock instance.
func NewIdentificationAuthorizationManager(ctrl *gomock.Controller) *IdentificationAuthorizationManager {
	mock := &IdentificationAuthorizationManager{ctrl: ctrl}
	mock.recorder = &IdentificationAuthorizationManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *IdentificationAuthorizationManager) EXPECT() *IdentificationAuthorizationManagerMockRecorder {
	return m.recorder
}

// CheckRoleAuthorizationOnTargetUser mocks base method.
func (m *IdentificationAuthorizationManager) CheckRoleAuthorizationOnTargetUser(ctx context.Context, initIdentAction, targetRealm, userID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckRoleAuthorizationOnTargetUser", ctx, initIdentAction, targetRealm, userID)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckRoleAuthorizationOnTargetUser indicates an expected call of CheckRoleAuthorizationOnTargetUser.
func (mr *IdentificationAuthorizationManagerMockRecorder) CheckRoleAuthorizationOnTargetUser(ctx, initIdentAction, targetRealm, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckRoleAuthorizationOnTargetUser", reflect.TypeOf((*IdentificationAuthorizationManager)(nil).CheckRoleAuthorizationOnTargetUser), ctx, initIdentAction, targetRealm, userID)
}
